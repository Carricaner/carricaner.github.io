[{"categories":["Programming Paradigm"],"content":"簡單介紹如何使用 AspectJ 實作 AOP","date":"2022-11-26","objectID":"/aspectj/","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"前言 一直都有聽說 AOP ( Aspect-Oriented Programming ) 的概念，但是一直沒有真正的動手實作。 利用這次寫這篇文章的機會，簡單整理一下 AOP 相關的概念以及實作。 ( Fact: 在跟 2022年 say goodbye 之前，補一下部落格發文進度 😏 ) Photo by Yaniv Knobel in Unsplash ","date":"2022-11-26","objectID":"/aspectj/:1:0","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"本文 ","date":"2022-11-26","objectID":"/aspectj/:2:0","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"相關名詞介紹 AOP ( Aspect-Oriented Programming ) AOP's definition 剖面導向程式設計 (AOP) 是電腦科學中的一種程式設計泛型，旨在將橫切關注點與業務主體進行進一步分離，以提高程式碼的模組化程度 — wiki 再用下面這張圖來說明： Photo derived from Konstantin’s article AOP 設計利用橫切的方式( cross-cutting ) 來加入額外邏輯。 像是圖中的「日誌 (Logging)」以及「安全驗證 (Security)」，這樣一來就可以避免在各個既有模組中一一加入邏輯，處理起來複雜、耗時且難以維護。 Join point 切面設計的切入點，會需要搭配 Pointcut 。 Pointcut 一種特殊的通用表示式 ( Regular Expression ) ，被用來定義是在哪些情況下應該要切入，並且依附某個切入點 ( Join Point )。 Advice 進入切入點之後要執行的邏輯。 Aspect 為收集各個地方的 cross-cutting concerns 之後獨立且可以重用的物件，通常一個 Aspect 會專注在一種邏輯上，像是日誌等等。 以上名詞之間的關係如下圖： Photo derived from openhom.cc ( 感謝良葛格對台灣技術的貢獻，本人從中受益良多，R.I.P. – 2022/11 ) ","date":"2022-11-26","objectID":"/aspectj/:2:1","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"使用 AspectJ What is AspectJ ? AspectJ 是一種實現 AOP 的 Java 擴充套件 — wiki 安裝 For Maven \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjrt\u003c/artifactId\u003e \u003cversion\u003e1.9.9.1\u003c/version\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.9.1\u003c/version\u003e \u003c/dependency\u003e 情境一：加入日誌 ( Logging ) 💡 假如我們想要針對 org.sample.entity 目錄底下所有的物件，在呼叫 getters \u0026 setters 的前後都紀錄我們客製化的日誌。 目錄底下的物件Car package org.example.entity; public class Car { private String name; public Car(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 新增一個EntityAspect來處理這個橫切邏輯。 package org.example.aop; import java.util.logging.Logger; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; @Aspect public class EntityAspect { private final Logger logger = Logger.getLogger(EntityAspect.class.getName()); @Pointcut(\"execution(* org.example.entity.*.get*()) \" + \"|| execution(* org.example.entity.*.set*(..))\") public void getterAndSetterJointPoint() {} @Before(\"getterAndSetterJointPoint()\") public void beforeGetterAndSetterAdvice() { logger.info(\"[EntityAspect] --\u003e Before advice executed!\"); } @After(\"getterAndSetterJointPoint()\") public void afterGetterAndSetterAdvice() { logger.info(\"[EntityAspect] --\u003e After advice executed!\"); } } @Pointcut中的表示式包含 jointpoint signature ( 範例中為 execution) 以及 regular expression ( 範例中為 * org.example.entity.*.get*())。 其中還可以搭配邏輯運算元 ( 範例中為 || )，更多的規則可以參考連結。 @Before \u0026 @After 指定 Advice 的邏輯是在 Join point 之前還是之後執行，裡面填入要綁定的 Pointcut method ( 範例中為getterAndSetterJointPoint() )。 在測試中看看結果 import org.example.entity.Car; import org.junit.jupiter.api.Test; class RawTest { @Test void testGetterAdnSetter() { Car car = new Car(\"SpeedWagon\"); System.out.println(\"The car's name: \" + car.getName()); } // Output: // Nov 28, 2022 3:06:22 PM org.example.aop.EntityAspect beforeGetterAndSetterAdvice // INFO: [EntityAspect] --\u003e Before advice executed! // Nov 28, 2022 3:06:22 PM org.example.aop.EntityAspect afterGetterAndSetterAdvice // INFO: [EntityAspect] --\u003e After advice executed! // Car's name: SpeedWagon } 可以看到在呼叫 getter 的前 ( Before ) 後 ( After ) 成功橫切插入我們要執行的邏輯。 情境二：檢查物件 ( Validation ) 💡 假如我們想要針對 org.sample.entity 目錄底下所有的物件在使用 new 來產生 instance 的時候，檢查裡面的欄位是否符合我們要的邏輯。 目錄底下的物件Triangle package org.example.entity; import java.util.Optional; public class Triangle { private float[] sides; public Triangle(float[] sides) { this.sides = sides; } // To validate if the triangle is a valid one. public Optional\u003cString\u003e validateTheTriangle() { if (sides.length != 3) return Optional.of(\"Sides number must be 3.\"); for (float side : sides) { if (side \u003c= 0) return Optional.of(\"Sides must be larger than 0.\"); if (sides[0] + sides[1] \u003c= sides[2] || sides[1] + sides[2] \u003c= sides[0] || sides[0] + sides[2] \u003c= sides[1]) return Optional.of(\"The sides cannot form a triangle.\"); } return Optional.empty(); } } 新增一個TriangleAspect來處理這個橫切邏輯。 package org.example.aop; import java.util.Optional; import java.util.logging.Logger; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.example.entity.Triangle; @Aspect public class TriangleAspect { private final Logger logger = Logger.getLogger(TriangleAspect.class.getName()); @Pointcut(\"execution(org.example.entity.*.new(..))\") public void triangleJointPoint() { } @After(\"triangleJointPoint()\") public void afterCreatingTriangleAdvice(JoinPoint joinPoint) { Triangle instance = (Triangle) joinPoint.getTarget(); Optional\u003cString\u003e op = instance.validateTheTriangle(); if (op.isPresent()) { logger.info(\"Invalid due to: \" + op.get()); } else { logger.info(\"Valid!\"); } } } 在測試中看看結果 import org.example.entity.Triangle; import org.junit.jupiter.api.Test; class RawTest { @Test void testValidTriangle()","date":"2022-11-26","objectID":"/aspectj/:2:2","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"總結 剖面導向程式設計 AOP ( Aspect-Oriented Programming ) 是一種設計方式，旨在將橫切關注點與業務主體分離，提高分離程度。 AOP 相關的概念：Join point, Pointcut, Advice \u0026 Aspect。 AspectJ 是一種實現 AOP 的 Java 擴充套件。相關的套件還有 Spring AOP。 AOP 可以利用的情境有 Tracing, Profiling \u0026 Logging, Pre- and Post- conditions 等等，可以參考官方列出的 情境。 ","date":"2022-11-26","objectID":"/aspectj/:3:0","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Programming Paradigm"],"content":"參考 AOP 觀念與術語 Intro to AspectJ AOP 與 Pointcut 淺談 【Spring Boot】第20課－切面導向程式設計（AOP） Introduction to Pointcut Expressions in Spring 【小家Spring】Spring AOP中@Pointcut切入点表达式最全面使用介绍 來談談 AOP (Aspect-Oriented Programming) 的精神與各種主流實現模式的差異 ","date":"2022-11-26","objectID":"/aspectj/:4:0","tags":["Java","Design","AOP","weaving","aspect","joinpoint","pointcut","advice","logging","immutable","domain"],"title":"Intro to AOP \u0026 AspectJ","uri":"/aspectj/"},{"categories":["Design Pattern"],"content":"讓我嘗試用 Java 來實作狀態模式吧！","date":"2022-08-11","objectID":"/state-machine/","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"前言 「狀態機模式」( State Pattern ) 是眾多設計模式中的一種，主要是用來處理一種物件可能依照不同的狀態而有不同行為的情況。 可以應用的場景有錄音機、紅綠燈等。若是商業方面的應用話，如包裹運送、文件傳簽等。 本文就以公司裡面會出現的「傳簽」來當作狀態模式的應用場景。 Photo by Signature Pro in Unsplash ","date":"2022-08-11","objectID":"/state-machine/:1:0","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"本文 ","date":"2022-08-11","objectID":"/state-machine/:2:0","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"場景一：簡單的傳簽系統 假設現在有一間新創公司剛成立一年，內部設計出如下圖的傳簽流程： 我準備了以下幾項東西來符合需求： 狀態機 ( State Machine ) 狀態 ( State ) 狀態資訊 ( StateInfo ) public interface StateMachine { /* Switch to next state */ void nextState(); /* Print current information */ void info(); } public interface State { /* Set next state */ void setNextState(State nextState); /* Switch to \u0026 return next state */ State nextState(); /* Print current state information */ void printStateInfo(); } public class SignatureStateMachine implements StateMachine { private State currentState; public SignatureStateMachine(State currentState) { this.currentState = currentState; } @Override public void nextState() { if (currentState != null) currentState = currentState.nextState(); } @Override public void info() { if (currentState != null) { currentState.printStateInfo(); } else { System.out.println(\"Already approved!\"); } } } public class SignatureState implements State { private State nextState; private StateInfo info; public SignatureState(StateInfo info) { this.info = info; } @Override public void setNextState(State nextState) { this.nextState = nextState; } @Override public State nextState() { return nextState; } @Override public void printStateInfo() { System.out.println(\"Now, the state is \" + info.getInfo()); } } public enum StateInfo { DRAFT(\"Draft\"), WATING_FOR_BOSS(\"Waiting for boss\"), APPROVED(\"Approved\"); private String info; StateInfo(String info) { this.info = info; } public String getInfo() { return info; } } 接著，我們來操作這次的狀態轉移。 public class SignatureDemo { public static void main(String[] args) { State draftState = new SignatureState(StateInfo.DRAFT); State waitingForBossState = new SignatureState(StateInfo.WATING_FOR_BOSS); State approvedState = new SignatureState(StateInfo.APPROVED); draftState.setNextState(waitingForBossState); waitingForBossState.setNextState(approvedState); approvedState.setNextState(null); StateMachine signSystem = new SignatureStateMachine(draftState); signSystem.info(); // \"Now, the state is Draft\" signSystem.nextState(); signSystem.info(); // \"Now, the state is Waiting for boss\" signSystem.nextState(); signSystem.info(); // \"Now, the state is Approved\" signSystem.nextState(); signSystem.info(); // \"Already approved!\" signSystem.nextState(); signSystem.info(); // \"Already approved!\" } } ","date":"2022-08-11","objectID":"/state-machine/:2:1","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"場景二：漸漸複雜的傳簽系統 上個例子比較簡單，現在開始加入一些現實上可能會遇到的問題，並且調整我們的程式碼來符合需求。加入考慮的項目如下： 公司雇用一位部門主管，文件簽核必須依序簽合。 部門主管與老闆可以退回文件，文件傳回上一狀態。 新的傳簽流程： 這次的情境不再是只有單一的狀態轉移，因此我們新建立簽署動作 ( Sign action ) 來當作狀態轉移的判斷標準。 簽署動作 ( Sign action ): public enum SignAction { SIGN(1), REJECT(2); private Integer code; SignAction(Integer code) { this.code = code; } } 我們沿用上面的狀態機 ( StateMachine ) 介面，但是改寫狀態 ( State ) 介面，並且重新實作它們。 重新定義的狀態介面如下： public interface State { /* Register a next state */ void registerNextState(SignAction action, State nextState); /* Switch to \u0026 return next state */ State nextState(SignAction action); /* Print current state information */ void printStateInfo(); } 狀態機 ( State Machine ) public class SignatureStateMachine implements StateMachine { private State currentState; public SignatureStateMachine(State currentState) { this.currentState = currentState; } @Override public void nextState(SignAction action) { if (currentState != null) currentState = currentState.nextState(action); } @Override public void info() { if (currentState != null) { currentState.printStateInfo(); } else { System.out.println(\"Already approved!\"); } } /* The static method to generate a custom signature system */ public static SignatureStateMachine generateSignatureSystem() { State draftState = new SignatureState(StateInfo.DRAFT); State waitingForLeaderState = new SignatureState(StateInfo.WATING_FOR_LEADER); State waitingForBossState = new SignatureState(StateInfo.WATING_FOR_BOSS); State approvedState = new SignatureState(StateInfo.APPROVED); draftState.registerNextState(SignAction.SIGN, waitingForLeaderState); waitingForLeaderState.registerNextState(SignAction.SIGN, waitingForBossState); waitingForLeaderState.registerNextState(SignAction.REJECT, draftState); waitingForBossState.registerNextState(SignAction.SIGN, approvedState); waitingForBossState.registerNextState(SignAction.REJECT, waitingForLeaderState); return new SignatureStateMachine(draftState); } } 狀態 ( State ) public class SignatureState implements State{ private Map\u003cSignAction, State\u003e map = new EnumMap\u003c\u003e(SignAction.class); private StateInfo info; public SignatureState(StateInfo info) { this.info = info; } @Override public void registerNextState(SignAction action, State nextState) { map.put(action, nextState); } @Override public State nextState(SignAction action) { if (map.containsKey(action)) { return map.get(action); } else { throw new StateError.NoSuchStateException(); } } @Override public void printStateInfo() { System.out.println(\"Now, the state is \" + info.getInfo() + \".\"); } } 此外，我們把狀態機直接封裝在文件 ( File ) 內部，讓操作的人可以只需針對文件進行操作，不用知道內部的狀態實際上是怎麼運作。 文件 ( File ) public class File { /* The file's content */ private String content; /* Whether the file is submitted. */ private boolean submitted = false; /* The map to store role \u0026 password pairs. */ private Map\u003cString, String\u003e roleToTokenMap = Map.ofEntries( Map.entry(\"Leader\", \"leader-pass-123\"), Map.entry(\"Boss\", \"boss-pass-456\") ); /* Inner state machine */ private SignatureStateMachine stateMachine = SignatureStateMachine.generateSignatureSystem(); public File(String content) { this.content = content; } /* Display the file's state information */ public void stateInfo() { stateMachine.info(); } /* To sign the file */ public void sign(String role, String password, SignAction action) { if (!submitted) throw new StateError.NotSubmittedException(); if (roleToTokenMap.containsKey(role) \u0026\u0026 roleToTokenMap.get(role).equals(password)) { stateMachine.nextState(action); if (role.equals(\"Leader\") \u0026\u0026 SignAction.REJECT.equals(action)) { submitted = false; } } } /* To submit the file */ public void submit() { if (!submitted) { stateMachine.nextState(SignAction.SIGN); submitted = true; } else { throw new StateError.AlreadySubmittedException(); } } } 狀態轉移如下： public class SignatureDemo2 { public static void main(String[] args) { String fileContent = \"Promotion request.\"; File newFile = new File(fileContent); newFile.stateInfo(); // \"Now, the state is Draft.\" newFile.submit(); newFile.stateInf","date":"2022-08-11","objectID":"/state-machine/:2:2","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"更多複雜的場景 真正在處理公司內部的業務邏輯的時候，複雜度往往沒有像上面兩個例子一樣簡單，好比下面傳簽的場景： 在處理複雜場景的時候，還可以考慮以下幾點，讓狀態模式更動態 ( 當然也就更複雜… 😅 ) 抽象化轉換過程 ( Transition )。 封裝狀態機 ( State Machine ) 到會改變狀態的物件當中。 使用列舉 ( Enumerate ) 方式來定義狀態資訊 ( State Information )、轉換過程 ( Transition ) 等。 除了可以轉換的狀態之外，也紀錄上一個狀態。 有機會轉換失敗的話，加入回滾 ( Rollback )的轉換。 當然…這篇文章就不寫出如何處理這樣的場景啦! 😉 ","date":"2022-08-11","objectID":"/state-machine/:2:3","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"總結 狀態模式 ( State Machine ) 主要是用來處理一種物件可能依照不同的狀態而有不同行為的情況。 狀態模式可以有不同的實作方式，但是核心精神在於處理狀態與轉移之間的關係。 設計過程中，可能涉及有限狀態機 ( Finite-State Machine ) 模型。 常見的生活例子有紅綠燈、各式電器等等。商業應用的話好比傳簽系統、包裹配送系統、電子下單系統等等。 若面對比較複雜的場景，Java 的使用者可以選擇套用 Spring Statemachine 。 ","date":"2022-08-11","objectID":"/state-machine/:3:0","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Design Pattern"],"content":"參考 State Machines: Components, Representations, Applications State Design Pattern in Java Validating Input with Finite Automata in Java A Guide to the Spring State Machine Project Implementing Simple State Machines with Java Enums Simple State Machines in Java ","date":"2022-08-11","objectID":"/state-machine/:4:0","tags":["Java","design","pattern","state","machine","transition"],"title":"進入設計模式的世界 -- 狀態機模式 ( State pattern )","uri":"/state-machine/"},{"categories":["Algorithm"],"content":"當一個交易包含了多個需要透過網路溝通的節點時，我們該如何處理呢？","date":"2022-02-28","objectID":"/two-pc-intro/","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"前言 由於現代方便的網路，使用者透過手機或電腦就能夠進行個人化的操作。 當一位使用者進行轉帳，目的是從 A 帳戶轉到 B 帳戶，開發者在背後是如何處理的呢？ 這篇文章主要會列舉並討論這種情境下會遇到的一些狀況。 進入本文前的幾點事項： 本文只列舉幾個種狀況來做『 概括性 』的討論，不涉及實作。 針對跨伺服器 ( 或分散式 ) 的事務處理還有其他種方式，本文主要針對二階段提交的部分討論。 文中每個節點 ( 伺服器 ) 都只會使用一個資料庫存放資料。 Photo by Eduardo Soares in Unsplash ","date":"2022-02-28","objectID":"/two-pc-intro/:1:0","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"本文 再討論情境問題之前，我們先來了解下面兩個概念: 交易 ( Transaction ) 二階段提交 ( two-phase commit, 2PC ) ","date":"2022-02-28","objectID":"/two-pc-intro/:2:0","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"交易 ( Transaction ) 交易是指複數個對資料庫的操作包成的一個邏輯單位，並且同時需要具備以下兩點特徵： 包含的複數個資料庫操作必須是一起成功執行 ( commit ) 或是一起不執行 ( rollback )。 每個事務之間不會互相干擾 ( Isolation )。 ","date":"2022-02-28","objectID":"/two-pc-intro/:2:1","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"二階段提交 ( two-phase commit, 2PC ) 二階段提交是實現跨服務間交易的一種演算法 ( 接下來都以 2PC 代稱 )。 設計 2PC 需要一個事務協調者 ( transaction coordinator, 簡稱 TC )，其負責與各個參與者 ( cohort ) 溝通來滿足交易的基本條件。 整個過程間分為兩個步驟：詢問 \u0026 提交。 流程： 使用者向 TC 提出交易需求 TC 詢問各個 cohorts cohorts 鎖定各自的資源 \u0026 回傳 Yes TC 下達 commit ＆回覆使用者 OK cohorts 執行交易邏輯並回傳 done 示意圖： 舉一個有趣例子，西方教堂舉辦婚禮的時候： 牧師分別問新郎以及新娘：你是否願意… 不管生老病死都… ?  協調者詢問參與者們 新郎新娘分別回答：願意！  參與者們回覆確認並且鎖定一生資源！？ 牧師：在此宣佈.. 正式成為夫妻！  協調者提交 ","date":"2022-02-28","objectID":"/two-pc-intro/:2:2","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"情境 使用者想要從 A 銀行帳戶 ( 簡稱 A 帳戶 ) 轉帳 100 元到 B 銀行帳戶 ( 簡稱 B 帳戶 )。 有幾點注意 \u0026 假設： 只考慮餘額充足的情況 ( A 帳戶餘額 \u003e 100 元 ) 假設 A, B 銀行都各自只用一個資料庫儲存資料。 必須滿足交易的基本原則。 假設有一個協調者管理這筆交易 ( 稱為 TC ) A 帳戶  cohort A B 帳戶  cohort B 直觀的做法就是： 先去 A 帳戶進行扣款 100 元 再去 B 帳戶進行存款 100 元 Done! 等等… 事情好像進行得過於順利…？ 那接下來討論幾個狀況 狀況一：帳戶 B 在交易過程中存款失敗 情境會演變成 A 帳戶已經扣除了 100 元，但是 B 帳戶卻沒有存到款的情形… 套用 2PC 的解決程序： 使用者向 TC 提出交易需求 TC 向帳戶 A, B 詢問可否進行交易 TC 收到帳戶 B 的失敗回覆 TC 向帳戶 A, B 傳送放棄的命令 ( abort ) TC 回傳轉帳失敗的訊息給使用者。 示意圖如下： 雖然交易失敗，但是確保了跨服務間資料的一致性。 狀況二：TC 遲遲沒有收到帳戶 A 的確認回覆 會演變成整筆交易停滯，遲遲沒有反應… 套用 2PC 的解決程序： 使用者向 TC 提出交易需求 TC 向帳戶 A, B 詢問可否進行交易 TC 在一定時間時間後沒有收到帳戶 A 的回覆 TC 向帳戶 A, B 傳送放棄的命令 ( abort ) TC 回傳轉帳失敗的訊息給使用者。 示意圖如下： 這樣一來，也可以確保後台的資料一致性。 狀況三：帳戶 A, B 皆向 TC 回傳確認訊息，但遲遲沒有收到 TC 的最終決定 我們以帳戶 B 的角度來看這種狀況： 可以單方面執行 commit 指令 ？不行 ❌  因為帳戶 A 可能傳給 TC 的確認指令是 No。  會演變成帳戶 A 沒有執行但是帳戶 B 有執行的狀況… 可以單方面執行 abort 指令 ？不行 ❌  因為帳戶 A 可能傳給 TC 的確認指令是 Yes。  會演變成帳戶 A 有執行但是帳戶 B 沒有執行的狀況… 那兩種行動都不能做，該怎麼辦？ 繼續等… ( 期盼奇蹟會出現 🦥 …) 實施 超時終止協議  簡單來說就是各個 cohort 之間互相確認狀況，因為涉及的狀況複雜，本文不討論 一般 cohorts 回覆 TC 之後就會鎖定各自的資源不要讓其他的邏輯干擾，但是現在 TC 卻沒有下達執行的命令，所以造成可怕的現象： 整個交易停滯 … 遇到這樣的問題，我們可以試試 三階段提交 ","date":"2022-02-28","objectID":"/two-pc-intro/:2:3","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"三階段提交 ( two-phase commit, 3PC ) 簡單來說，就是將二階段提交的第一個步驟 ( 詢問 ) 拆成：詢問 + 鎖定資源，最後才是下達執行的命令，所以總共有三個階段組成。 三階段提交的核心思想是詢問時不鎖定資源，除非所有人都同意才鎖定資源。 整個流程會是： 使用者向 TC 提出轉帳的需求 TC 詢問各個 cohorts cohorts 都返回 Yes TC 下達 pre-commit cohorts 鎖定各自資源並且都回傳 Yes TC 下達最終 commit ＆ 回覆使用者 OK 示意圖： 再回來看狀況三的情形，我們可以設計成當帳戶 A,B 一段時內間沒有收到來自 TC 最終的 commit 訊息時就釋放資源並且取消操作，這樣一來也可以保持資料的一致性。 ","date":"2022-02-28","objectID":"/two-pc-intro/:2:4","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"兩軍問題 ( Two General’s Problem ) 兩軍問題是一個思維性實驗問題，狀況如下： 有兩支軍隊，分別由一位將軍領導，共同目的是要擊潰某個敵方城池。 兩軍派出的信使必須要通過敵方領地，並且信使有可能被敵方俘虜。 一定要兩軍同時發起進攻才會成功，只有一支軍隊進攻會導致失敗。 發現不管設計怎麼樣的方法都無法保證兩軍一定可以在同一時間進攻，所以這個問題基本上是無解的。 兩軍問題就是對現代每個節點使用網際網路彼此進行溝通的影射。 我們沒有完美的辦法，但是可以思索出可接受的辦法。 ","date":"2022-02-28","objectID":"/two-pc-intro/:2:5","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"總結 二階段提交是一種用來達成分散式交易的設計方式。 二階段提交分為「 詢問 」以及「 提交 」兩個階段。 二階段提交需要有協調者 ( Transaction Coordinator ) 以及參與者 ( Cohort )。 協調者只是一個抽象的角色，實際上可以把它放在某一個參與者之中來實作也是 OK。 分散式事務最常遇到的狀況分類為：重啟 \u0026 響應超時 ( timeout )，其中後者最為複雜麻煩。 三階段提交分為「 詢問 」,「 鎖定資源 」\u0026「 提交 」三個階段。 三階段提交可以用來彌補二階段參與者確認回覆即鎖定資源造成等待的窘境。 建立在不可靠的溝通渠道的兩軍問題根本上是無解，只能設計較能接受的處理方式。 現實中實作 2PC 或是 3PC 都將會是很大的挑戰。 ","date":"2022-02-28","objectID":"/two-pc-intro/:3:0","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"},{"categories":["Algorithm"],"content":"參考 二階段提交 兩軍問題 正确理解二阶段提交（Two-Phase Commit） 分布式系统的事务处理 ","date":"2022-02-28","objectID":"/two-pc-intro/:4:0","tags":["distribution","algorithm","commit","abort","rollback","consistency"],"title":"跨伺服器交易處理 — 認識二階段提交 ( 2PC )","uri":"/two-pc-intro/"}]